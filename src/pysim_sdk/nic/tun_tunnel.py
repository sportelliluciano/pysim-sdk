import os
import select
import fcntl
import struct
import subprocess
import threading

from scapy.all import raw, IP, ICMP

from pysim_sdk.nic.nic import BaseNetworkInterface
from pysim_sdk.utils import log
from pysim_sdk.utils.ip_address import ip2str

_UNIX_TUNSETIFF = 0x400454CA
_UNIX_IFF_TUN = 0x0001
_UNIX_IFF_NO_PI = 0x1000

DEFAULT_DNS_SERVER = "1.1.1.1"


class WlanTunnel(BaseNetworkInterface):
    """
    Tunnels the virtual wireless interface to a TUN device
    """

    if_type = "tun"

    def __init__(self, events_sink, tun_name="home0"):
        self.events_sink = events_sink
        self._network = None
        self._mask = None
        self._name = tun_name
        self._descriptor = None
        self._thread = threading.Thread(target=self._main_thread, name=self._name)
        self._quit_signal = False
        self.gateway_ip = None

    def enable_ap_mode(self, network, mask):
        if self._descriptor:
            assert (
                self._network == network and self._mask == mask
            ), f"Tried to enable AP mode multiple times with different networks"
            return

        self._network = network
        self._mask = mask
        self._thread.start()

    def _main_thread(self):
        self.gateway_ip = ip2str(self._network | 1)
        self.ip_addr = self.gateway_ip
        self.mask = ip2str(self._mask)
        self._descriptor = os.open("/dev/net/tun", os.O_RDWR)
        fcntl.ioctl(
            self._descriptor,
            _UNIX_TUNSETIFF,
            struct.pack(
                "16sH", self._name.encode("ASCII"), _UNIX_IFF_TUN | _UNIX_IFF_NO_PI
            ),
        )

        # Bring interface up
        exec_ip(f"link set {self._name} up")

        # Set interface IP / mask
        exec_ip(
            f"addr add {ip2str(self._network | 100)}/{self._mask.bit_count()} dev {self._name}"
        )

        # Add entry to routing table
        exec_ip(f"route add default via {ip2str(self._network | 1)} dev {self._name}")

        # Disable IPv6
        exec_ip(f"-6 addr flush {self._name}")

        self.configure_nameserver(DEFAULT_DNS_SERVER)

        while not self._quit_signal:
            rlist, *_ = select.select([self._descriptor], [], [], 1)
            if not rlist:
                continue

            packet = IP(os.read(self._descriptor, 65536))
            if packet[IP].dst == ip2str(self._network | 1):
                self.count_packet_in(raw(packet))
                self.handle_gateway_ip_datagram(packet)
            elif IP in packet:
                self.count_packet_in(raw(packet))
                self.events_sink.put((self, "packet-received", raw(packet[IP])))
            else:
                log.warn("Unhandled packet %s", packet)

    @staticmethod
    def configure_nameserver(server):
        try:
            with open("/etc/resolv.conf", "w") as f:
                f.write("# Generated by PySIM\n")
                f.write(f"nameserver {server}\n")
        except Exception as e:
            log.warn("Could not update DNS configuration: %r", e)

    def send_packet(self, packet: bytes):
        """
        Sends packet from node to tap device (home device)
        """
        if self._descriptor is None:
            ip_packet = IP(packet)
            log.error(f"[WLAN TUNNEL] Discarding {ip_packet} -- Tunnel not configured")
        else:
            result = os.write(self._descriptor, packet)
            assert result == len(packet), f"not all bytes were sent"
            self.count_packet_out(packet)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._quit_signal = True
        if self._thread.is_alive():
            self._thread.join()
        if self._descriptor:
            os.close(self._descriptor)
            self._descriptor = None

    def __str__(self):
        return "wlan-tunnel"

    def handle_gateway_ip_datagram(self, packet):
        log.info("[WLAN TUNNEL] virtual gateway: Got echo request from: %s", packet.dst)
        if ICMP in packet and packet[ICMP].type == 8:
            icmp_reply = packet[ICMP]
            icmp_reply.type = 0
            icmp_reply.code = 0
            icmp_reply.chksum = None
            reply = IP(dst=packet[IP].src, src=packet[IP].dst) / icmp_reply
            self.events_sink.put((self, "packet-received", raw(reply)))
        else:
            log.warn(
                "[WLAN TUNNEL] virtual gateway: Unknown packet received: %s", packet
            )


def exec_ip(cmd_line):
    subprocess.call(["/sbin/ip"] + cmd_line.split())
